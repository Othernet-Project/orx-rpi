"""
Functions for working with mount points
"""


import os
from subprocess import call
from collections import namedtuple


MTAB_FILE = '/proc/mounts'
MOUNT = '/bin/mount'
NTFS_MOUNT = '/usr/bin/ntfs-3g'
UMOUNT = '/bin/umount'


#: namedtuple representing a single mtab entry
MtabEntry = namedtuple('MtabEntry', ['dev', 'mdir', 'fstype', 'opts', 'cfreq',
                                     'cpass'])


def get_mtab():
    """
    Iterator yielding mount points that appear in mtab file.
    """
    fd = open(MTAB_FILE, 'r')
    for l in fd:
        yield MtabEntry(*l.strip().split())
    fd.close()


def mount(dev, target, fs=None, opts='defaults', bind=False):
    """
    Mount a filesystem and return the mount command's exit code. The device to
    be mounted is specified by ``dev``. This can also be a directory in case of
    bind mount. The ``target`` is a directory. If it does not exist, it is
    created automatically.

    The filesystem can be specified with the ``fs`` argument. Without this
    argument, filesystem is guessed by the OS.

    Mount options default to ``'defaults'``. Use the ``opts`` argument to
    customize options.

    The ``bind`` argument is a boolean flag that tells the mount command to to
    a bind mount. ``fs`` and ``opts`` arguments are completely ignored when
    doing bind mounts.

    .. warning::
        This function only ensures that target exists, but does not check
        whether ``dev`` is present.
    """
    # Ensure target exists before mounting
    try:
        os.makedirs(target)
    except os.error:
        # This menas target already exists, so it's OK to pass here.
        pass

    # We special-case ntfs-3g because with subprocess.call() the mount helper
    # cannot be located.
    if fs == 'ntfs':
        cmd = [NTFS_MOUNT, dev, target]
    else:
        cmd = [MOUNT, dev, target]
    if bind:
        # If it's a bind mount, we ignore all the other arguments
        cmd.insert(1, '--bind')
    else:
        if fs and fs != 'ntfs':
            cmd.extend(['-t', fs])
        cmd.extend(['-o', opts])

    return call(cmd)


def umount(path, force=False):
    """
    Unmount a device or mount point and return the umount command's exit code.
    ``path`` can be either a device node, or a mount point.

    This function returns immediately if the ``path`` does not exist. In this
    case, 1 is returned as exit code.

    The ``force`` argument is used to perform a forced unmount.
    """
    if not os.path.exists(path):
        return 1

    cmd = [UMOUNT, path]
    if force:
        cmd.insert(1, '-f')

    return call(cmd)

